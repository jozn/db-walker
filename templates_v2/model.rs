// DO NOT MODIFY AUTO-GENERATED BY PB-WALKER
use mysql_async::prelude::*;
use mysql_async::{FromRowError, OptsBuilder, Params, Row, Pool};
use mysql_common::row::ColumnIndex;

use mysql_common::value::Value;
use crate::mysql_shared::*;

#[derive(Default, Clone, PartialEq, Eq, Debug)]
pub struct {{ .TableNameCamel }}  { // {{ .TableName }}
{{- range .Columns }}
    pub {{ .ColumnName }}: {{ .RustType }},
{{- end }}
}

impl FromRow for {{ .TableNameCamel }} {
    fn from_row_opt(row: Row) -> Result<Self, FromRowError>
    where
        Self: Sized,
    {
        Ok({{ .TableNameCamel }}  {
        {{- range .Columns }}
            {{ .ColumnName }}: row.get({{ .GetColIndex }}).unwrap_or_default(),
        {{- end }}
        })
    }
}

{{- $tableScheme := .SchemeTable }}

impl {{ .TableNameCamel }} {

{{- if .AutoIncrKey }}
    pub async fn insert(&self, spool: &SPool) -> Result<{{ .TableNameCamel }},MyError> {
        let mut conn = spool.pool.get_conn().await?;

        let query = format!(r"INSERT INTO {:}.{{ .TableName }} ({{ colnames .Columns .AutoIncrKey.ColumnName }}) VALUES ({{ colvals_dollar . .Columns .AutoIncrKey.ColumnName }})",&spool.database);
        let p = Params::Positional(vec![{{ .GetRustParamNoneIncrKeys }}]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        let mut cp = self.clone();
        cp.{{ .AutoIncrKey.ColumnName }} = qr.last_insert_id().unwrap() as {{ .AutoIncrKey.RustType }};
        Ok(cp)
    }
{{ else }}
    pub async fn insert(&self, spool: &SPool) -> Result<{{ .TableNameCamel }},MyError> {
        let mut conn = spool.pool.get_conn().await?;

        let query = format!(r"INSERT INTO {:}.{{ .TableName }} ({{ colnames .Columns }}) VALUES ({{ colvals_dollar . .Columns }})",&spool.database);
        let p = Params::Positional(vec![{{ .GetRustParam }}]);

        conn.exec_iter(
            query, p
        ).await?;

        let cp = self.clone();
        Ok(cp)
    }
{{- end }}

    // todo add replace with coping insert after it's complete

    pub async fn update(&self, spool: &SPool) -> Result<(),MyError> {
        let mut conn = spool.pool.get_conn().await?;
        let query = format!(r"UPDATE `{:}`.{{ .TableName }}` SET {{ .GetRustUpdateFrag }} WHERE {{ .GetRustUpdateKeysWhereFrag }} ", &spool.database);
        let p = Params::Positional(vec![{{ .GetRustParamNoPrimaryKeys }}, {{ .GetRustParamPrimaryKeys }} ]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        Ok(())
    }

    pub async fn delete(&self, spool: &SPool) -> Result<(),MyError> {
        let mut conn = spool.pool.get_conn().await?;

        let query = format!(r"DELETE FROM `{:}`.{{ .TableName }}` WHERE {{ .GetRustUpdateKeysWhereFrag }} ", &spool.database);
        let p = Params::Positional(vec![{{ .GetRustParamPrimaryKeys }}]);

        conn.exec_drop(
            query, p
        ).await?;

        Ok(())
    }
}


#[derive(Default, Debug)]
pub struct {{ .TableNameCamel }}Selector {
    q: TQuery
}

impl {{ .TableNameCamel }}Selector {
    pub fn new() -> Self {
        {{ .TableNameCamel }}Selector::default()
    }

    pub fn limit(&mut self, size: u32) -> &mut Self {
        self.q.limit = size;
        self
    }

    pub fn offset(&mut self, size: u32) -> &mut Self {
        self.q.offset = size;
        self
    }

    pub fn select_all(&mut self) -> &mut Self {
        // Default is select *
        self
    }

    //each column select
    {{- range .Columns }}
    pub fn select_{{ .ColumnName }}(&mut self) -> &mut Self {
        self.q.select_cols.push("{{.ColumnName}}");
        self
    }
    {{ end }}

    pub async fn _get_rows_with_size(&mut self, session: &SPool, size: i64) -> Result<Vec<{{ .TableNameCamel }}>, MyError>   {
        let mut conn = session.pool.get_conn().await?;
        let(cql_query, query_values) = self.q._to_sql_selector();

        println!("{} - {:?}", &cql_query, &query_values);

        let p = Params::Positional(query_values);

        let query_result = conn
            .exec_map(
                cql_query,p,
                |obj: {{ .TableNameCamel }}| obj
            ).await?;

        Ok(query_result)
    }

    pub async fn get_rows(&mut self, session: &SPool) -> Result<Vec<{{ .TableNameCamel }}>, MyError>{
        self._get_rows_with_size(session,-1).await
    }

    pub async fn get_row(&mut self, session: &SPool) -> Result<{{ .TableNameCamel }}, MyError>{
        let rows = self._get_rows_with_size(session,1).await?;

        let opt = rows.get(0);
        match opt {
            Some(row) => Ok(row.to_owned()),
            None => Err(MyError::NotFound)
        }
    }

    // Modifiers
    {{ .GetRustOrdersTmplOut }}
    {{ .GetRustWheresTmplOut }}
    {{ .GetRustWhereInsTmplOut }}
}

// Updater
{{- $updaterType := printf "%sUpdater" .TableNameCamel }}

#[derive(Default, Debug)]
pub struct {{ $updaterType }} {
    q: TQuery
}

impl {{ $updaterType }} {
    pub fn new() -> Self {
        {{ $updaterType }}::default()
    }

    pub fn limit(&mut self, size: u32) -> &mut Self {
        self.q.limit = size;
        self
    }

    //each column delete
    {{- range .Columns }}
    pub fn set_{{ .ColumnName }}(&mut self, val :{{ .RustTypeBorrow }}) -> &mut Self {
        self.q.updates.insert("{{ .ColumnName }}",val.into());
        self
    }
    {{ end }}

    pub async fn update(&mut self, session: &SPool) -> Result<(),MyError> {
        update_rows(&self.q, session).await
    }

    {{ .GetRustOrdersTmplOut }}
    {{ .GetRustWheresTmplOut }}
    {{ .GetRustWhereInsTmplOut }}
}

// Deleter
{{- $deleterType := printf "%sDeleter" .TableNameCamel }}

#[derive(Default, Debug)]
pub struct {{ $deleterType }} {
    q: TQuery
}

impl {{ $deleterType }} {
    pub fn new() -> Self {
        {{ $deleterType }}::default()
    }

    pub fn limit(&mut self, size: u32) -> &mut Self {
        self.q.limit = size;
        self
    }

    //each column delete
    {{- range .Columns }}
    pub fn delete_{{ .ColumnName }}(&mut self) -> &mut Self {
        self.q.delete_cols.push("{{.ColumnName}}");
        self
    }
    {{ end }}

    pub async fn delete(&mut self, session: &SPool) -> Result<(),MyError> {
        delete_rows(&self.q, session).await
    }

    {{ .GetRustOrdersTmplOut }}
    {{ .GetRustWheresTmplOut }}
    {{ .GetRustWhereInsTmplOut }}
}

pub async fn {{ .TableName }}_mass_insert(arr :&Vec<{{ .TableNameCamel }}>, spool: &SPool) -> Result<(),MyError> {
    let mut conn = spool.pool.get_conn().await?;
    if arr.len() == 0 {
        return Err(MyError::EmptySql)
    }

   {{- if .AutoIncrKey }}
    let mut insert_fields = "({{ colnames .Columns .AutoIncrKey.ColumnName }})";

    let mut vals_str = "({{ colvals_dollar . .Columns .AutoIncrKey.ColumnName }}), ".repeat(arr.len());
   {{ else }}
     let mut insert_fields = "({{ colnames .Columns }})";

     let mut vals_str = "({{ colvals_dollar . .Columns }}), ".repeat(arr.len());
   {{- end }}
    let vals_str = &vals_str[0..(vals_str.len()-2)];

    let query = format!(r"INSERT INTO {:}.tweet {:} VALUES {:}", &spool.database, insert_fields, vals_str);

    let mut arr_vals = vec![];
    for ar in arr {
        {{- range .Columns }}
                   arr_vals.push(ar.{{ .ColumnName }}.clone().into());
        {{- end }}
    }

    let p = Params::Positional(arr_vals);

    println!("{} - {:?}", &query, &p);

    let qr = conn.exec_iter(
        query, p
    ).await?;

    Ok(())
}