// DO NOT MODIFY AUTO-GENERATED BY PB-WALKER
use mysql_async::prelude::*;
use mysql_async::{FromRowError, OptsBuilder, Params, Row, Pool};
use mysql_common::row::ColumnIndex;

use mysql_common::value::Value;

//use crate::xc::CWError;

// Every Table Must Have Primary Keys to Be Included In This Output
// Primiay Keys must be one column (no compostion types yet)
// Primiay Keys can be 1) Auto Increment 2) Other self Inserted

// Implemention is simple NOT many features is suported in Rust version:
// Keep mysql data types in int, bigint, text, varchar, bool, blob
// No signed integer is supported
// For now Primary key should only be numbers
// Not fully ORM is supported: limited to CRUD on rows + Indexes querys

{{range . }}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct {{ .TableNameJava }}  { // {{ .TableName }}
{{- range .Columns }}
    pub {{ .ColumnName }}: {{ .RustTypeOut }},
{{- end }}
}

impl FromRow for {{ .TableNameJava }} {
    fn from_row_opt(row: Row) -> Result<Self, FromRowError>
    where
        Self: Sized,
    {
        Ok({{ .TableNameJava }}  {
        {{- range .Columns }}
            {{ .ColumnName }}: row.get({{ .GetColIndex }}).unwrap_or_default(),
        {{- end }}
        })
    }
}

{{- $tableScheme := .TableSchemeOut }}

impl {{ .TableNameJava }} {

{{- if .IsAutoIncrement  }}
    pub async fn insert(&self, pool: &Pool) -> Result<{{ .TableNameJava }},MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"INSERT INTO {{ $tableScheme }} ({{ colnames .Columns .PrimaryKey.ColumnName }}) VALUES ({{ colvals_dollar . .Columns .PrimaryKey.ColumnName }})";
        let p = Params::Positional(vec![{{ .GetRustParamNoPrimaryKey }}]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        let mut cp = self.clone();
        cp.{{ .PrimaryKey.ColumnName }} = qr.last_insert_id().unwrap() as {{ .PrimaryKey.RustTypeOut }};
        Ok(cp)
    }
{{ else }}
    pub async fn replace(&self, pool: &Pool) -> Result<{{ .TableNameJava }},MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"REPLACE INTO {{ $tableScheme }} ({{ colnames .Columns }}) VALUES ({{ colvals_dollar . .Columns }})";
        let p = Params::Positional(vec![{{ .GetRustParam }}]);

        conn.exec_iter(
            query, p
        ).await?;

        let cp = self.clone();
        Ok(cp)
    }
{{- end }}

    pub async fn replace_dep(&self, pool: &Pool) -> Result<{{ .TableNameJava }},MyError> {
        let mut conn = pool.get_conn().await?;
{{ if .IsAutoIncrement  }}
        let query = r"INSERT INTO {{ $tableScheme }} ({{ colnames .Columns .PrimaryKey.ColumnName }}) VALUES ({{ colvals_dollar . .Columns .PrimaryKey.ColumnName }})";
        let p = Params::Positional(vec![{{ .GetRustParamNoPrimaryKey }}]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        let mut cp = self.clone();
        cp.{{ .PrimaryKey.ColumnName }} = qr.last_insert_id().unwrap() as {{ .PrimaryKey.RustTypeOut }};
{{ else }}
        let query = r"REPLACE INTO {{ $tableScheme }} ({{ colnames .PrimaryKeys}}) VALUES ({{ colvals_dollar . .PrimaryKeys}})";
        let p = Params::Positional(vec![{{ .GetRustParam }}]);

        conn.exec_iter(
            query, p
        ).await?;

        let cp = self.clone();
{{ end }}
       Ok(cp)
    }

    pub async fn update(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;
        let query = r"UPDATE {{ $tableScheme }} SET {{ .GetRustUpdateFrag }} WHERE {{ .GetRustUpdateKeysWhereFrag }} ";
        let p = Params::Positional(vec![{{ .GetRustParamNoPrimaryKey }},  self.{{ .PrimaryKey.ColumnName }}.clone().into() ]);

        let qr = conn.exec_iter(
            query, p
        ).await?;

        Ok(())
    }

    pub async fn delete(&self, pool: &Pool) -> Result<(),MyError> {
        let mut conn = pool.get_conn().await?;

        let query = r"DELETE FROM {{ $tableScheme }} WHERE {{ .GetRustUpdateKeysWhereFrag }} ";
        let p = Params::Positional(vec![self.{{ .PrimaryKey.ColumnName }}.clone().into()]);

        conn.exec_drop(
            query, p
        ).await?;

        Ok(())
    }
}


#[derive(Default, Debug)]
pub struct {{ .TableNameJava }}Selector {
    wheres: Vec<WhereClause>,
    select_cols: Vec<&'static str>,
    order_by:  Vec<&'static str>,
    limit: u32,
    offset: u32,
}

impl {{ .TableNameJava }}Selector {
    pub fn new() -> Self {
        {{ .TableNameJava }}Selector::default()
    }

    pub fn limit(&mut self, size: u32) -> &mut Self {
        self.limit = size;
        self
    }

    pub fn offset(&mut self, size: u32) -> &mut Self {
        self.offset = size;
        self
    }

    pub fn select_all(&mut self) -> &mut Self {
        // Default is select *
        self
    }

    //each column select
    {{- range .Columns }}
    pub fn select_{{ .ColumnNameRust }}(&mut self) -> &mut Self {
        self.select_cols.push("{{.ColumnName}}");
        self
    }
    {{ end }}

    fn _to_cql(&self) ->  (String, Vec<Value>)  {
        let cql_select = if self.select_cols.is_empty() {
            "*".to_string()
        } else {
            self.select_cols.join(", ")
        };

        let mut cql_query = format!("SELECT {} FROM {{.TableSchemeOut}}", cql_select);

        let (cql_where, where_values) = _get_where(self.wheres.clone());

        if where_values.len() > 0 {
            cql_query.push_str(&format!(" WHERE {}",&cql_where));
        }

        if self.order_by.len() > 0 {
            let cql_orders = self.order_by.join(", ");
            cql_query.push_str( &format!(" ORDER BY {}", &cql_orders));
        };

        if self.limit != 0  {
            cql_query.push_str(&format!(" LIMIT {} ", self.limit));
        };

        if self.offset != 0  {
            cql_query.push_str(&format!(" OFFSET {} ", self.offset));
        };

        (cql_query, where_values)
    }

    pub async fn _get_rows_with_size(&mut self, session: &Pool, size: i64) -> Result<Vec<{{ .TableNameRust }}>, MyError>   {
        let mut conn = session.get_conn().await?;
        let(cql_query, query_values) = self._to_cql();

        println!("{} - {:?}", &cql_query, &query_values);

        let p = Params::Positional(query_values);

        let query_result = conn
            .exec_map(
                cql_query,p,
                |obj: {{ .TableNameRust }}| obj
            ).await?;

        Ok(query_result)
    }

    pub async fn get_rows(&mut self, session: &Pool) -> Result<Vec<{{ .TableNameRust }}>, MyError>{
        self._get_rows_with_size(session,-1).await
    }

    pub async fn get_row(&mut self, session: &Pool) -> Result<{{ .TableNameRust }}, MyError>{
        let rows = self._get_rows_with_size(session,1).await?;

        let opt = rows.get(0);
        match opt {
            Some(row) => Ok(row.to_owned()),
            None => Err(MyError::NotFound)
        }
    }

    // Modifiers

    {{ .GetRustSelectorOrders }}

    {{ .GetRustWheresTmplOut }}

    //{* .GetRustWhereInsTmplOut *}

}
{{end}}


///////////////// SHARED CODE ///////////
#[derive(Debug, Clone)]
pub struct WhereClause {
    // pub condition: &'static str,
    pub condition: String,
    pub args: Value,
}

fn _get_where(wheres: Vec<WhereClause>) ->  (String, Vec<Value>) {
    let mut values = vec![];
    let  mut where_str = vec![];

    for w in wheres {
        where_str.push(w.condition);
        values.push(w.args)
    }
    let cql_where = where_str.join(" ");

    (cql_where, values)
}

#[derive(Debug)]
pub enum MyError { // MySQL Error
    NotFound,
    MySqlError(mysql_async::Error),
}

impl From<mysql_async::Error> for MyError{
    fn from(err: mysql_async::Error) -> Self {
        MyError::MySqlError(err)
    }
}

