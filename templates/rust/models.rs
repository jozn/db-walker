// DO NOT MODIFY AUTO-GENERATED BY PB-WALKER
use mysql_async::prelude::*;
use mysql_async::{FromRowError, OptsBuilder, Params, Row, Pool};
use mysql_common::row::ColumnIndex;

use shared::xc::CWError;

// Every Table Must Have Primary Keys to Be Included In This Output
// Primiay Keys must be one column (no compostion types yet)
// Primiay Keys can be 1) Auto Increment 2) Other self Inserted

// Implemention is simple NOT many features is suported in Rust version:
// Keep mysql data types in int, bigint, text, varchar, bool, blob
// No signed integer is supported
// For now Primary key should only be numbers
// Not fully ORM is supported: limited to CRUD on rows + Indexes querys

{{range . }}

#[derive(Debug, PartialEq, Eq, Clone)]
pub struct {{ .TableNameJava }}  { // {{ .TableName }}
{{- range .Columns }}
    pub {{ .ColumnName }}: {{ .RustTypeOut }},
{{- end }}
}

impl FromRow for {{ .TableNameJava }} {
    fn from_row_opt(row: Row) -> Result<Self, FromRowError>
    where
        Self: Sized,
    {
        Ok({{ .TableNameJava }}  {
        {{- range .Columns }}
            {{ .ColumnName }}: row.get({{ .GetColIndex }}).unwrap(),
        {{- end }}
        })
    }
}

{{- $tableScheme := .TableSchemeOut }}

impl {{ .TableNameJava }} {
    pub async fn insert(&self, pool: &Pool) -> Result<{{ .TableNameJava }},CWError> {
        let mut conn = pool.get_conn().await.unwrap();
{{ if .IsAutoIncrement  }}
        let query = r"INSERT INTO {{ $tableScheme }} ({{ colnames .Columns .PrimaryKey.ColumnName }}) VALUES ({{ colvals_dollar . .Columns .PrimaryKey.ColumnName }})";
        let p = Params::Positional(vec![{{ .GetRustParamNoPrimaryKey }}]);

        let qr = conn.exec_iter(
            query, p
        ).await.unwrap();

        let mut cp = self.clone();
        cp.{{ .PrimaryKey.ColumnName }} = qr.last_insert_id().unwrap() as {{ .PrimaryKey.RustTypeOut }};
{{ else }}
        let query = r"INSERT INTO {{ $tableScheme }} ({{ colnames .Columns}}) VALUES ({{ colvals_dollar . .Columns}})";
        let p = Params::Positional(vec![{{ .GetRustParam }}]);

        conn.exec_iter(
            query, p
        ).await.unwrap();

        let cp = self.clone();
{{ end }}
       Ok(cp)
    }

    pub async fn update(&self, pool: &Pool) -> Result<(),CWError> {
        let mut conn = pool.get_conn().await.unwrap();
        let query = r"UPDATE {{ $tableScheme }} SET {{ .GetRustUpdateFrag }} WHERE {{ .PrimaryKey.ColumnName }} = ? ";
        let p = Params::Positional(vec![{{ .GetRustParamNoPrimaryKey }},  self.{{ .PrimaryKey.ColumnName }}.clone().into() ]);

        let qr = conn.exec_iter(
            query, p
        ).await.unwrap();

        Ok(())
    }

    pub async fn delete(&self, pool: &Pool) -> Result<(),CWError> {
        let mut conn = pool.get_conn().await.unwrap();

        let query = r"DELETE FROM {{ $tableScheme }} WHERE {{ .PrimaryKey.ColumnName }} = ? ";
        let p = Params::Positional(vec![self.{{ .PrimaryKey.ColumnName }}.clone().into()]);

        conn.exec_drop(
            query, p
        ).await.unwrap();

        Ok(())
    }
}

{{end}}